package com.byteowls.vaadin.chartjs.options.scale;

import java.io.Serializable;

import com.byteowls.vaadin.chartjs.options.Position;
import com.byteowls.vaadin.chartjs.utils.JUtils;
import com.byteowls.vaadin.chartjs.utils.JsonBuilder;
import elemental.json.Json;
import elemental.json.JsonObject;

/**
 * @author michael@byteowls.com
 */
public abstract class BaseScale<B extends BaseScale<?>> implements JsonBuilder, Serializable {

    private static final long serialVersionUID = -2382244938070735956L;

    private String id;
    protected String type;
    protected Boolean display;
    protected Position position;
    protected Boolean stacked;
    protected Integer barThickness;
    protected Integer maxBarThickness;
    protected Double categoryPercentage;
    protected Double barPercentage;
    protected GridLines<B> gridLines;
    protected Ticks<B> ticks;
    protected ScaleLabel<B> scaleLabel;

    /**
     * "category", "linear", "logarithmic", "time", "radialLinear"
     */
    @SuppressWarnings("unchecked")
	public B type(String type) {
        this.type = type;
        return (B) this;
    }

    /**
     * If true, show the scale including gridlines, ticks, and labels. Overrides gridLines.display, scaleLabel.display, and ticks.display.
     */
    @SuppressWarnings("unchecked")
	public B display(boolean display) {
        this.display = display;
        return (B) this;
    }

    /**
     * The ID is used to link datasets and scale axes together. The properties `datasets.xAxisID` or `datasets.yAxisID` have to match the scale properties `scales.xAxes.id` or `scales.yAxes.id`. This is especially needed if multi-axes charts are used.
     */
    @SuppressWarnings("unchecked")
	public B id(String id) {
        this.id = id;
        return (B) this;
    }

    /**
     * If true, bars are stacked on the x-axis
     */
    @SuppressWarnings("unchecked")
	public B stacked(boolean stacked) {
        this.stacked = stacked;
        return (B) this;
    }

    /**
     * Manually set width of each bar in pixels. If not set, the bars are sized automatically.
     */
    @SuppressWarnings("unchecked")
	public B barThickness(int barThickness) {
        this.barThickness = barThickness;
        return (B) this;
    }

    /**
     * Set this to ensure that the automatically sized bars are not sized thicker than this. Only works if barThickness is not set (automatic sizing is enabled).
     */
    @SuppressWarnings("unchecked")
	public B maxBarThickness(int maxBarThickness) {
        this.maxBarThickness = maxBarThickness;
        return (B) this;
    }

    /**
     * Percent (0-1) of the available width (the space between the gridlines for small datasets) for each data-point to use for the bars.
     */
    @SuppressWarnings("unchecked")
	public B categoryPercentage(double categoryPercentage) {
        this.categoryPercentage = categoryPercentage;
        return (B) this;
    }

    /**
     * Percent (0-1) of the available width each bar should be within the category percentage. 1.0 will take the whole category width and put the bars right next to each other.
     */
    @SuppressWarnings("unchecked")
	public B barPercentage(double barPercentage) {
        this.barPercentage = barPercentage;
        return (B) this;
    }


    /**
     * Position of the scale.
     */
	@SuppressWarnings("unchecked")
	public B position(Position position) {
        this.position = position;
        return (B) this;
    }

    /**
     * It defines options for the grid lines that run perpendicular to the axis.
     */
    public GridLines<B> gridLines() {
        if (gridLines == null) {
            gridLines = new GridLines<>(getThis());
        }
        return gridLines;
    }

    /**
     * Define options for the scale title.
     */
    public ScaleLabel<B> scaleLabel() {
        if (scaleLabel == null) {
            scaleLabel = new ScaleLabel<>(getThis());
        }
        return scaleLabel;
    }

    /**
     * It defines options for the tick marks that are generated by the axis.
     */
    public Ticks<B> ticks() {
        if (ticks == null) {
            ticks = new Ticks<>(getThis());
        }
        return ticks;
    }

    public abstract B getThis();


    @Override
    public JsonObject buildJson() {
        JsonObject map = Json.createObject();
        JUtils.putNotNull(map, "type", type);
        JUtils.putNotNull(map, "display", display);
        JUtils.putNotNull(map, "id", id);
        JUtils.putNotNull(map, "stacked", stacked);
        JUtils.putNotNull(map, "barThickness", barThickness);
        JUtils.putNotNull(map, "maxBarThickness", maxBarThickness);
        JUtils.putNotNull(map, "categoryPercentage", categoryPercentage);
        JUtils.putNotNull(map, "barPercentage", barPercentage);
        if (position != null) {
            JUtils.putNotNull(map, "position", position.name().toLowerCase());
        }
        JUtils.putNotNull(map, "gridLines", gridLines);
        JUtils.putNotNull(map, "scaleLabel", scaleLabel);
        JUtils.putNotNull(map, "ticks", ticks);
        return map;
    }
}
